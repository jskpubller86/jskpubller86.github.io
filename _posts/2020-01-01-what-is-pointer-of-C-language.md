---
title : 포인터
categories : language c
---

C에서는 메모리의 주소를 참조할 수 있는 변수가 있다.

이것을 포인터라한다. 

일단 메모리 주소부터 이해해보자.

모든 변수는 메모리에 저장된다. 

그리고 메모리는 주소를 가지고 있다. 

만약 a라는 변수를 선언했고 이것의 메모리 주소가 10000이라고 해보자

```c
int a = 10;

// a의 메모리 주소는 a'10000
```

여기서 메모리 주소를 b'20000, a'10000 이런식으로 표현할 것인데 보기 편하라고 하는 것이니 큰 의미를 두지말자.

아무튼 계속해서  b라는 변수를 만들고 a를 대입 해보자.

```c
int b = a;

// b = 10
// b의 주소는 b'20000
```

그러면 b는 10이라는 값을 가지게 된다. 

여기서 b를 20으로 변경해보자.

```c
b = 20;

// b = 20
// b'20000 = 20
```

a는 어떻게 될까?

a는 그대로 10이다.

즉 위에서 했던 것은 그 변수의 값만 대입한 것이기에 a, b가 서로 다른 메모리 주소로 10을 가졌고 b만 20으로 변경된 것이다.

그러면 b를 변경할 때 a도 같이 변경하고 싶을 때 어떻게 해야 될까?

바로 참조 방식인 포인터를 이용하는 것이다.

포인터는 메모리 주소를 참조할 수 있다.

위에서 b를 포인터로 지정한다.

변수의 메모리 주소를 반환할 경우 변수명 앞에 & 기호를 붙인다.

```c
int *b = &a;

// b에 a의 메모리 주소 10000을 대입
// b'20000 = a'10000
```

b 포인터를 통해서 a'10000 주소의 값인 10을 20으로 변경을 해보자.

```c
*b = 20;

// a'10000 = 20
```

포인트의 참조된 주소의 데이터를 가리킬 경우 변수명 앞에 * 기호를 붙인다.

만약 포인트의 참조된 주소 가져올 경우 다음과 같이 할 수 있다.

```c
printf("%d", &*b);

// a'10000
```

<br>

## 초기화

포인터를 초기화하는 방법은 크게 두가지다.

하나는 선언 후 초기화, 다른 하나는 선언과 함께 초기화하는 것이다.

```c
// 선언 후 초기화
int a=10;
int *b;

b = &a

//-----------------
// 선언과 함께 초기화
int a = 10;
int *b = &a;
```


### 포인터와 문자열

문자열은 문자 배열이다.

포인터와 문자열을 결합하면 다음과 같은 표현이 가능하다.

```c
char me[] = "i am developer";
char *myArray = me;

// Array의 첫번째 배열의 주소를 대입하게 됨.

printf("%s", myArray); // i am developer

printf("%c", *myArray); // i

printf("%c", *(myArray + 1)); // 공백

printf("%c", *(myArray + 2)); // a

printf("%c", *(myArray + 3)); // m
.....
```

<br>

### 포인터와 배열

포인터도 배열이 있다.

먼저 일반 배열은 다음과 같이 표현한다.

```c
char Array[3][10] = {"what", "are", "you"};
// 3행 10열의 배열이 생성
```

| |0|1|2|3|4|5|6|7|8|9|
|-|-|-|-|-|-|-|-|-|-|-|
|0|w|h|a|t| | | | | | |
|1|a|r|e| | | | | | | |
|2|y|o|u| | | | | | | |


위 배열에서는 값이 없는 빈 배열 공간이 많이 생긴다.

하지만 포인터는 필요한 만큼의 배열을 가질 수 있다.

```c
char *myArray[3] = {{"what", "are", "you"}};
// 3행이 생기고 각 글자 크기만큼 열이 생김
```

| |||||||||||
|-|-|-|-|-|-|-|-|-|-|-|
|0|w|h|a|t|
|1|a|r|e|
|2|y|o|u|



### 포인터와 함수

함수 포인터를 이용하면 하나의  하나의 함수 포인터로 여러 함수 기능을 스위칭할 수 있다.

이때는 변수의 주소값 반환처럼 &기호를 붙일 필요가 없다.

```c
void sum(int a, int b) {
    printf("%d", a + b);
};
void avg(int a, int b) {
    printf("%d", (a + b) / 2);
};
void (*func)(int a, int b);


void main(){
    int a =10, b=5;
    func = sum;
    func(a, b);
    // 15
    func = avg;
    func(a, b);
    // 7
}
```


=끝=


























